# ---------------------------------------------------------------------------------
# ---------------------------- CONFIGURATION --------------------------------------
# ---------------------------------------------------------------------------------
BASE_NAMES = REDIS LANGFLOW
DOCKERHUB_BASE_NAMES = PGBOUNCER POSTGRES
# Portforward targets for local debugging
PORTFORWARD = POSTGRES PGBOUNCER REDIS LANGFLOW

# Default credentials (injectable via command line)
PG_PASS ?= password
REDIS_PASS ?= redissecret
AWS_KEY_ID ?= AKIAX7SUEXAT7OWTXRLH
AWS_SECRET_KEY ?= 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
AWS_REGION ?= eu-central-1
ECR_URL ?= 548858542119.dkr.ecr.eu-central-1.amazonaws.com
LANGFLOW_SECRET_KEY ?= super_secret_dev_key
LANGFLOW_SUPERUSER_PASS ?= service_user
LANGFLOW_PASS ?= langflow
# ---------------------------------------------------------------------------------
# ---------------------------- AWS & BASE IMAGES ----------------------------------
# ---------------------------------------------------------------------------------
aws-login:
	@echo "======================= CONFIGURING AWS CLI =========================="
	@aws configure set aws_access_key_id "$(AWS_KEY_ID)"; \
	aws configure set aws_secret_access_key "$(AWS_SECRET_KEY)"; \
	aws configure set region "$(AWS_REGION)";
	@echo "======================= LOGGING IN TO AWS ECR =========================="
	@aws ecr get-login-password --region $(AWS_REGION) | \
	docker login --username AWS --password-stdin "$(ECR_URL)"

base-build:
	@echo "----------------- Starting port-forward to local registry -------------------"
	@kubectl port-forward svc/registry 5000:5000 > /dev/null 2>&1 &
	@echo "Waiting for port-forward..." && sleep 5

	@echo "----------------- Pulling, Tagging, and Pushing Base Images -------------------"
	@# These variables are now read from the ConfigMaps generated by Helm
	@IMG_PREFIX="tis"; \
	ENV_TAG="prd"; \
	BITBUCKET_BRANCH="master"; \
	AWS_ECR_REGISTRY_URL="$(ECR_URL)"; \
	for base_name in $(BASE_NAMES); do \
    		config_map=$$(echo $$base_name | tr 'A-Z' 'a-z')-config; \
    		\
    		echo "Reading metadata from ConfigMap: $$config_map"; \
    		IMAGE_NAME=$$(kubectl get configmap $$config_map -o jsonpath="{.data.$${base_name}_IMAGE}"); \
    		VERSION=$$(kubectl get configmap $$config_map -o jsonpath="{.data.$${base_name}_VERSION}"); \
    		LOCAL_TAG=$$(kubectl get configmap $$config_map -o jsonpath="{.data.$${base_name}_BUILT_IMAGE}"); \
    		\
    		ECR_IMAGE_PATH="$${AWS_ECR_REGISTRY_URL}/$${IMG_PREFIX}-$${IMAGE_NAME}:$${ENV_TAG}-$${BITBUCKET_BRANCH}-$${VERSION}"; \
    		LOCAL_IMAGE_PATH="localhost:5000/$${LOCAL_TAG}"; \
    		\
    		echo "--- Processing service: $$base_name ---"; \
    		echo "Pulling from: $${ECR_IMAGE_PATH}"; \
    		docker pull "$${ECR_IMAGE_PATH}"; \
    		echo "Tagging as: $${LOCAL_IMAGE_PATH}"; \
    		docker tag "$${ECR_IMAGE_PATH}" "$${LOCAL_IMAGE_PATH}"; \
    		docker push "$${LOCAL_IMAGE_PATH}"; \
    		echo "--- Done ---"; \
    	done

	@echo "----------------- Pulling, Tagging, and Pushing Docker Hub Base Images -------------------"
	@for base_name in $(DOCKERHUB_BASE_NAMES); do \
			config_map=$$(echo $$base_name | tr 'A-Z' 'a-z')-config; \
			\
			echo "Reading metadata from ConfigMap: $$config_map"; \
			DOCKERHUB_IMAGE_PATH=$$(kubectl get configmap $$config_map -o jsonpath="{.data.$${base_name}_IMAGE}"); \
			LOCAL_TAG=$$(kubectl get configmap $$config_map -o jsonpath="{.data.$${base_name}_BUILT_IMAGE}"); \
			LOCAL_IMAGE_PATH="localhost:5000/$${LOCAL_TAG}"; \
			\
			echo "--- Processing Docker Hub service: $$base_name ---"; \
			echo "Pulling from: $${DOCKERHUB_IMAGE_PATH}"; \
			docker pull "$${DOCKERHUB_IMAGE_PATH}"; \
			echo "Tagging as: $${LOCAL_IMAGE_PATH}"; \
			docker tag "$${DOCKERHUB_IMAGE_PATH}" "$${LOCAL_IMAGE_PATH}"; \
			docker push "$${LOCAL_IMAGE_PATH}"; \
			echo "--- Done ---"; \
		done

	@echo "----------------- Verifying images in local registry -------------------"
	@curl -s http://localhost:5000/v2/_catalog
	@echo "----------------- Killing port-forward process -------------------"
	@fuser -k 5000/tcp > /dev/null 2>&1 || true

# ---------------------------------------------------------------------------------
# ------------------------------ MINIKUBE MANAGEMENT ------------------------------
# ---------------------------------------------------------------------------------
mk-up: mk-config
	@echo "----------------- Starting Minikube -------------------"
	minikube start --insecure-registry="192.168.0.0/16" --force

mk-stop:
	@echo "----------------- Stopping Minikube -------------------"
	-minikube stop

mk-delete:
	@echo "----------------- Deleting Minikube cluster -------------------"
	-minikube delete

mk-restart: mk-stop mk-up
	@echo "----------------- Restarting Minikube -------------------"

mk-setup:
	@echo "----------------- Mounting working directory into Minikube -------------------"
	docker cp . minikube:/workspace

# ---------------------------------------------------------------------------------
# -------------------------------- PRE-BUILD CHECKS -------------------------------
# ---------------------------------------------------------------------------------
pre-build:
	@echo "----------------- Auto-configuring resource limits -------------------"
	@CPU_CORES=$$(nproc); \
	TOTAL_MEM_GB=$$(free -g | awk '/^Mem:/ {print $$2}'); \
	export LIMIT_CPU=$$(($$CPU_CORES - 2)); \
	export LIMIT_MEM=$$(($$TOTAL_MEM_GB - 4))Gi; \
	export REQUEST_CPU=1; \
	export REQUEST_MEM=4Gi; \
	echo "Detected $$CPU_CORES CPU cores and $$TOTAL_MEM_GB GB RAM."; \
	envsubst < kubernetes/limits.yaml.tpl > kubernetes/limits.yaml;
	@echo "kubernetes/limits.yaml generated successfully."

# ---------------------------------------------------------------------------------
# --------------------------------- INFRA SETUP -----------------------------------
# ---------------------------------------------------------------------------------
mk-config:
	@echo "----------------- Configuring Minikube VM Resources -------------------"
	minikube config set insecure-registry "registry.default.svc.cluster.local:5000"
	minikube config set insecure-registry "localhost:5000"

infra-setup:
	@echo "----------------- Applying Kubernetes Registry & Infrastructure -------------------"
	kubectl apply -f kubernetes/registry.yaml
	kubectl rollout status deployment registry -n default --timeout=180s
	@echo "Waiting for registry pod..."
	@kubectl wait --for=condition=ready pod -l app=registry -n default --timeout=90s
	@echo "----------------- Applying Namespace Limits -------------------"
	kubectl apply -f kubernetes/limits.yaml

# ---------------------------------------------------------------------------------
# ----------------------------------- BOOTSTRAP -----------------------------------
# ---------------------------------------------------------------------------------

# CRITICAL: Helm Install must run BEFORE builds, because Helm creates the ConfigMaps
# that the build scripts depend on.
# bootstrap: mk-delete mk-up mk-setup pre-build infra-setup helm-install aws-login base-build build-k8s rollout-restart wait-for-ready init-langflow-users
bootstrap: mk-delete mk-up mk-setup pre-build infra-setup helm-install aws-login base-build build-k8s rollout-restart wait-for-ready verify-infra
	@echo "==========================================================="
	@echo "ðŸŽ‰ System bootstrapped successfully via Helm & Kaniko!"
	@echo "   Access services via: localhost:6433 (PgBouncer), localhost:5433 (Postgres), localhost:6380 (Redis)"
	@echo "==========================================================="

init-k8s: up-helm init-langflow-users

# ---------------------------------------------------------------------------------
# ----------------------------------- BUILD JOBS ----------------------------------
# ---------------------------------------------------------------------------------

build-k8s: mk-setup build-k8s-postgres build-k8s-pgbouncer build-k8s-redis build-k8s-langflow

build-k8s-postgres:
	@echo "----------------- Building Postgres for Kubernetes -------------------"
	@kubectl delete job postgres-build --ignore-not-found=true
	@kubectl apply -f kubernetes/postgres/postgres-build-job.yaml
	@echo "Waiting for Postgres build job..."
	@kubectl wait --for=condition=complete job/postgres-build --timeout=180s || \
		(echo "!!! Postgres build failed, showing logs: !!!" && kubectl logs job/postgres-build --follow && exit 1)
	@echo "Postgres build completed."

build-k8s-pgbouncer:
	@echo "----------------- Building PgBouncer for Kubernetes -------------------"
	@kubectl delete job pgbouncer-build --ignore-not-found=true
	@kubectl apply -f kubernetes/pgbouncer/pgbouncer-build-job.yaml
	@echo "Waiting for PgBouncer build job..."
	@kubectl wait --for=condition=complete job/pgbouncer-build --timeout=180s || \
		(echo "!!! PgBouncer build failed, showing logs: !!!" && kubectl logs job/pgbouncer-build --follow && exit 1)
	@echo "PgBouncer build completed."

build-k8s-redis:
	@echo "----------------- Building Redis for Kubernetes -------------------"
	@kubectl delete job redis-build --ignore-not-found=true
	@kubectl apply -f kubernetes/redis/redis-build-job.yaml
	@echo "Waiting for Redis build job..."
	@kubectl wait --for=condition=complete job/redis-build --timeout=180s || \
		(echo "!!! Redis build failed, showing logs: !!!" && kubectl logs job/redis-build --follow && exit 1)
	@echo "Redis build completed."

build-k8s-langflow:
	@echo "----------------- Building Langflow for Kubernetes -------------------"
	@kubectl delete job langflow-build --ignore-not-found=true
	@kubectl apply -f kubernetes/langflow/langflow-build-job.yaml
	@echo "Waiting for Langflow build job..."
	@kubectl wait --for=condition=complete job/langflow-build --timeout=180s || \
		(echo "!!! Langflow build failed, showing logs: !!!" && kubectl logs job/langflow-build --follow && exit 1)
	@echo "Langflow build completed."

# ---------------------------------------------------------------------------------
# ----------------------------------- HELM DEPLOY ---------------------------------
# ---------------------------------------------------------------------------------
helm-install:
	@echo "----------------- Deploying TIS Stack with Helm -------------------"
	@MINIKUBE_IP=$$(minikube ip); \
	echo "--> Using Registry at: $$MINIKUBE_IP:30500"; \
	helm upgrade --install tis-stack ./charts/tis-stack \
		--namespace default \
		--set global.registry="$$MINIKUBE_IP:30500" \
		--set global.aws.accessKeyId="$(AWS_KEY_ID)" \
		--set global.aws.secretAccessKey="$(AWS_SECRET_KEY)" \
		--set postgres.auth.password="$(PG_PASS)" \
		--set redis.auth.password="$(REDIS_PASS)" \
		--set langflow.auth.secretKey="$(LANGFLOW_SECRET_KEY)" \
		--set langflow.auth.superuserPassword="$(LANGFLOW_SUPERUSER_PASS)" \
		--set langflow.auth.password="$(LANGFLOW_PASS)"

helm-uninstall:
	@echo "----------------- Removing TIS Stack -------------------"
	helm uninstall tis-stack || true

helm-template:
	@echo "----------------- Debugging Helm Templates -------------------"
	helm template tis-stack ./charts/tis-stack --debug

# ---------------------------------------------------------------------------------
# ----------------------------------- UTILS ---------------------------------------
# ---------------------------------------------------------------------------------
rollout-restart:
	@echo "----------------- Restarting deployments to pick up new images -------------------"
	kubectl rollout restart deployment postgres
	kubectl rollout restart deployment redis
	kubectl rollout restart deployment pgbouncer
	@echo "Waiting for rollouts..."
	kubectl rollout status deployment postgres
	kubectl rollout status deployment redis
	kubectl rollout status deployment pgbouncer

wait-for-ready:
	@echo "----------------- Waiting for all deployments to be ready -------------------"
	@kubectl wait --for=condition=available deployment/postgres --timeout=120s
	@kubectl wait --for=condition=available deployment/redis --timeout=120s
	@kubectl wait --for=condition=available deployment/pgbouncer --timeout=120s
	@echo "Waiting for Langflow..."
	@kubectl wait --for=condition=available deployment/langflow --timeout=180s

ps-k8s:
	@echo "----------------- Listing running Kubernetes pods -------------------"
	@kubectl get pods

port-forward-services:
	@echo "----------------- Cleaning up old port-forwards... -------------------"
	@-pkill -f "kubectl port-forward" || true
	@sleep 2

	@echo "----------------- Starting new port-forwards... -------------------"
	@for portforward in $(PORTFORWARD); do \
		echo "--> Forwarding $$portforward..."; \
		portforward_lower=$$(echo $$portforward | tr 'A-Z' 'a-z'); \
		config_map=$${portforward_lower}-config; \
        PORT=$$(kubectl get configmap $$config_map -o jsonpath="{.data.$${portforward}_PORT}"); \
        REDIRECT_PORT=$$(kubectl get configmap $$config_map -o jsonpath="{.data.$${portforward}_REDIRECT_PORT}"); \
        nohup kubectl port-forward svc/$${portforward_lower} "$${REDIRECT_PORT}:$${PORT}" > /dev/null 2>&1 & \
        echo "    DONE: localhost:$${REDIRECT_PORT} -> svc/$${portforward_lower}:$${PORT}"; \
	done

up-helm: helm-install port-forward-services

# ---------------------------------------------------------------------------------
# ------------------------------------ TESTING ------------------------------------
# ---------------------------------------------------------------------------------
monitor-db:
	@bash kubernetes/monitoring/db.sh

monitor-pgbouncer:
	@bash kubernetes/monitoring/bouncer.sh

test-redis:
	@chmod +x kubernetes/tests/test-redis.sh
	@bash kubernetes/tests/test-redis.sh

test-db:
	@chmod +x kubernetes/tests/test-db.sh
	@bash kubernetes/tests/test-db.sh

test-gunicorn:
	@chmod +x kubernetes/tests/test-gunicorn.sh
	@bash kubernetes/tests/test-gunicorn.sh

test-citus:
	@chmod +x kubernetes/tests/test-citus.sh
	@bash kubernetes/tests/test-citus.sh

verify-infra:
	@echo "==========================================================="
	@echo "ðŸ” VERIFYING INFRASTRUCTURE HEALTH (Pre-Init)"
	@echo "==========================================================="
	@make test-redis
	@echo "-----------------------------------------------------------"
	@make test-db
	@echo "-----------------------------------------------------------"
	@make test-gunicorn
	@echo "==========================================================="
	@echo "âœ… INFRASTRUCTURE IS HEALTHY. READY FOR INIT."

# ---------------------------------------------------------------------------------
# -------------------------------- INIT SCRIPTS -----------------------------------
# ---------------------------------------------------------------------------------

init-langflow-users:
	@echo "----------------- Executing init scripts inside the Langflow container -------------------"
	@LANGFLOW_POD=$$(kubectl get pods -l app=langflow -o jsonpath='{.items[0].metadata.name}'); \
	if [ -z "$$LANGFLOW_POD" ]; then echo "X Langflow pod not found!"; exit 1; fi; \
	\
	echo "--- Creating /app/tmp directory inside the pod ---"; \
	kubectl exec "$${LANGFLOW_POD}" -- mkdir -p /app/tmp; \
	\
	echo "--- Running init_service_user.py in pod: $${LANGFLOW_POD} ---"; \
	kubectl exec "$${LANGFLOW_POD}" -- python /app/init/python/init_service_user.py; \
	\
	echo "--- Running init_public_user.py in pod: $${LANGFLOW_POD} ---"; \
	kubectl exec "$${LANGFLOW_POD}" -- python /app/init/python/init_public_user.py; \
	\
	echo "Init scripts finished successfully." \

init-citus-sharding:
	@echo "----------------- âš¡ APPLYING CITUS SHARDING âš¡ -------------------"; \
	PG_POD=$$(kubectl get pods -l app=postgres -o jsonpath='{.items[0].metadata.name}'); \
	if [ -z "$$PG_POD" ]; then echo "âŒ Postgres pod not found!"; exit 1; fi; \
	\
	echo "--> Listing existing tables (for verification):"; \
	kubectl exec "$$PG_POD" -- bash -c "export PGPASSWORD='$(PG_PASS)'; psql -U postgres_user -d langflow_db -c '\dt'" || true; \
	\
	echo "--> Distributing 'transaction' table (Shard Key: id)..."; \
	kubectl exec "$$PG_POD" -- bash -c "export PGPASSWORD='$(PG_PASS)'; psql -U postgres_user -d langflow_db -c \"SELECT create_distributed_table('transaction', 'id');\"" || echo "âš ï¸  Warning: 'transaction' already distributed or failed."; \
	\
	echo "--> Distributing 'message' table (Shard Key: id - because we cannot modify Langflow PK)..."; \
	kubectl exec "$$PG_POD" -- bash -c "export PGPASSWORD='$(PG_PASS)'; psql -U postgres_user -d langflow_db -c \"SELECT create_distributed_table('message', 'id');\"" || echo "âš ï¸  Warning: 'message' already distributed or failed."; \
	\
	echo "âœ… Sharding setup finished."

switch-to-transaction:
	@echo "----------------- âš¡ OPTIMIZING: Switching PgBouncer to TRANSACTION Mode âš¡ -------------------"
	@# A --reuse-values megtartja a jelszavakat Ã©s egyÃ©b beÃ¡llÃ­tÃ¡sokat, csak a mÃ³dot Ã­rja felÃ¼l
	@helm upgrade tis-stack ./charts/tis-stack --reuse-values --set pgbouncer.pool.mode=transaction
	@\
	echo "--> Restarting PgBouncer to apply config..."; \
	kubectl rollout restart deployment pgbouncer; \
	echo "--> Restarting Langflow to reset connection pool..."; \
	kubectl rollout restart deployment langflow; \
	\
	echo "--> Waiting for stability..."; \
	kubectl rollout status deployment pgbouncer; \
	kubectl rollout status deployment langflow; \
	echo "âœ… Switch complete. System is ready for load."

# ---------------------------------------------------------------------------------
# --------------------------------- BENCHMARK -------------------------------------
# ---------------------------------------------------------------------------------
create-test-flow:
	@echo "--- Creating test flow for benchmarking ---"
	@LANGFLOW_POD=$$(kubectl get pods -l app=langflow -o jsonpath='{.items[0].metadata.name}'); \
	OUTPUT=$$(kubectl exec "$${LANGFLOW_POD}" -- python /app/init/python/init_benchmark_flow.py); \
	echo "$$OUTPUT"; \
	\
	FLOW_ID=$$(echo "$$OUTPUT" | grep 'BENCHMARK_DATA:FLOW_ID=' | cut -d'=' -f2 | tr -d '\r'); \
	API_KEY=$$(echo "$$OUTPUT" | grep 'BENCHMARK_DATA:API_KEY=' | cut -d'=' -f2 | tr -d '\r'); \
	\
	echo "Saving to ConfigMap and Secret..."; \
	kubectl patch configmap langflow-config --patch "{\"data\":{\"BENCHMARK_FLOW_ID\":\"$$FLOW_ID\"}}"; \
	kubectl patch secret tis-app-secrets --patch "{\"data\":{\"BENCHMARK_API_KEY\":\"$$(echo -n $$API_KEY | base64)\"}}"; \
	\
	echo "Saving to local files for verification..."; \
	echo "$$FLOW_ID" > .benchmark_flow_id; \
	echo "$$API_KEY" > .benchmark_api_key; \
	echo "Test flow created. Flow ID saved to .benchmark_flow_id, API key saved to .benchmark_api_key"

build-benchmark-image:
	@echo "----------------- Starting port-forward to local registry for benchmark image -------------------"
	@kubectl port-forward svc/registry 5000:5000 & export BG_PID=$$!; \
	echo "Waiting for port-forward (PID: $$BG_PID)..." && sleep 5; \
	echo "----------------- Building and Pushing Benchmark Image -------------------"; \
	docker build --no-cache -t localhost:5000/benchmark:latest -f kubernetes/benchmark/docker/Dockerfile kubernetes/benchmark; \
	docker push localhost:5000/benchmark:latest; \
	echo "----------------- Killing port-forward process (PID: $$BG_PID) -------------------"; \
	kill $$BG_PID;

run-benchmark:
	@echo "--- Applying Benchmark RBAC and running Job ---"
	@kubectl apply -f kubernetes/benchmark/rbac.yaml
	@kubectl delete job langflow-benchmark --ignore-not-found=true
	@export REGISTRY_HOST=$$(minikube ip); \
	export FLOW_ID=$$(kubectl get configmap langflow-config -o jsonpath='{.data.BENCHMARK_FLOW_ID}'); \
	export API_KEY=$$(kubectl get secret tis-app-secrets -o jsonpath='{.data.BENCHMARK_API_KEY}' | base64 --decode); \
	envsubst < kubernetes/benchmark/benchmark-job.yaml | kubectl apply -f -

	@echo "--- Waiting for benchmark pod to start..."
	@BENCHMARK_POD_NAME=""; \
	while [ -z "$$BENCHMARK_POD_NAME" ]; do \
	   echo -n "."; \
	   sleep 1; \
	   BENCHMARK_POD_NAME=$$(kubectl get pods -l job-name=langflow-benchmark -o jsonpath='{.items[0].metadata.name}' 2>/dev/null); \
	done; \
	echo ""; \
	echo "Waiting for benchmark pod to be ready..."; \
	kubectl wait --for=condition=ready pod/$$BENCHMARK_POD_NAME --timeout=120s; \
	echo "Benchmark pod is ready: $$BENCHMARK_POD_NAME. Streaming logs in real-time..."; \
	kubectl logs -f "$$BENCHMARK_POD_NAME"

	@echo "--- Log stream finished. Verifying final Job status... ---"
	@sleep 5
	@JOB_STATUS=$$(kubectl get job langflow-benchmark -o jsonpath='{.status.conditions[?(@.type=="Complete")].status}'); \
	if [ "$$JOB_STATUS" != "True" ]; then \
	   echo "!!! Benchmark job did not complete successfully. Check logs above for errors. !!!"; \
	   exit 1; \
	fi

	@echo "--- Benchmark Job completed successfully. ---"
